\documentclass[class=article, crop=false]{standalone}
\input{~/github/latex/Preamble}

\fancyhf{}
\lhead{CS32 Midterm $1$ Notes}
\rhead{Page \thepage}
\pagestyle{fancy}

\begin{document}
  \tableofcontents
  \newpage
  \section{Algorithms and Data Structures}
  \begin{definition}{Algorithms}
    An \emph{algorithm} is a set of instructions/steps that solves a particular problem.
  \end{definition}
  Each algorithm operates on input data, and produces an output result. Algorithms can be classified by how long they take to run on particular input, and by the quality of their results. 
  \begin{definition}{Data Structures}
    A \emph{data structure} is the set of variable(s) that an algorithm uses to solve a problem.
  \end{definition}
  To solve a problem, you have $o$ design both the algorithms and the data structures together. You then need to provide a set of simple ``interface'' functions to let any programmer use them easily. We call this an ADT, or abstract data type.
  \subsection{Abstract Data Types}
  \begin{definition}{ADT}
    An \emph{ADT} or \emph{abstract data type} is a coordinated group of data structures, algorithms, and interface functions that is used to solve a particular problem.
  \end{definition}
  In an ADT, the data structures and algorithms are kept secret, while the interface is public to enable the rest of the program to use the ADT. Typically, a program is built from a collection of ADTs, each of which solves a different sub-problem.
  \subsubsection{ADTs in C++}
  In C++, we use classes to define ADTs in our programs. Each C++ class can hold algorithms, data, and interface functions.
  \begin{itemize}
    \item Once the class has been defined, the rest of our program can treat the functions as a ``black box'', i.e. not knowing how exactly how the functions work.
    \item All our program needs to do is call the functions in our class' public interface.
    \item All of the underlying data structures and algorithms are hidden from the user.
    \item The rest of the program can ignore the details of how things work and just use its features.
  \end{itemize}
  \begin{note}{}
    The benefit of this is that you can change the implementation of the class as much as you want, and as long as the interface functions do what they're supposed to, nothing will break outside of the class. This reduces complexity by breaking down large, complex problems into smaller, self-contained chunks.
  \end{note}
  \newpage
  \subsection{Defining a Class in C++}
  We first write the outer shell of the class and give it a name, then give the class public and private variables/functions.
  \begin{lstlisting}
    // Nerd.h
    class Nerd
    {
    public:
      Nerd(int stink, int IQ) {
        myStinkiness = stink;
        myIQ = IQ;
      }
      void study (int hours) {
        myStinkiness += 3*hours;
        myIQ *= 1.01;
      }
      int getStinkyLevel() {
        int total_stink = myIQ * 10 + myStinkiness;
        return total_stink;
      }
    private:
      int myStinkiness, myIQ;
    };
  \end{lstlisting}
  \begin{note}{}
    Don't forget the semicolon at the end of the class!
  \end{note}
  \subsection{Using a New Class}
  Once we define a new class, we can use it to define variables like any traditional data type.
  \begin{itemize}
    \item The class defines a new data type like int, float, or string.
    \item You typically define each class in its own \texttt{.h} file (``header file'') and put the file in the same folder as your \texttt{.cpp} files. For example, in a file titled \texttt{ucla.cpp}, we could have
    \begin{lstlisting}
      // ucla.cpp
      #include "Nerd.h"
      int main()
      {
        int num_nerds = 1;
        Nerd david(30, 150);

        david.study(10);
      }
    \end{lstlisting}
    \item A header file is similar to a \texttt{.cpp} file except you typically only put class declarations and constants in it (you typically put the actual function bodies in your \texttt{.cpp} file).
    \item To import the contents of a header file, just put \texttt{\#include "filename.h"} at the beginning of the file.
    \item Once an instance of the class is defined, you can call its member functions, i.e. \texttt{study}.
    \begin{note}{}
      A class' primitive types start out with random values and not zero, so remember to initialise them with the constructor.
    \end{note}
    \item You typically only use member variables to store permanent attributes of a class, i.e. \texttt{myStinkiness} and \texttt{myIQ}.
    \item All functions in the \texttt{public} section of your class can be seen/called by all parts of your program.
    \item All functions and data defined in the \texttt{private} section of your class are hidden from the rest of your program.
    \begin{definition}{Encapsulation}
      Hiding the internal implementation details of a class (from the rest of your program) is called \emph{encapsulation}.
    \end{definition}
  \end{itemize}
  \section{Constructors and Destructors}
  \textbf{Main Idea.} A constructor is used to reset an object's member variables when the object is first created; otherwise they'd be random. An object will often reserve memory slots from the operating system while it runs, so we need a destructor function to free that memory when we delete the object.
  \subsection{Constructor Basics}
  We create a constructor just like any other function, but it doesn't have a return type (not even \texttt{void}).
  \begin{lstlisting}
    // Gassy
    class Gassy
    {
    public:
      // The constructor
      Gassy(int age, bool ateBeans)
      {
        m_age = age;
        m_ateBeans = ateBeans;
      }

      int getFartsPerHr()
      {
        if (m_ateBeans == true)
          return(100);
        return(3 * m_age);
      }
    private:
      // Member variables
      int m_age;
      bool m_ateBeans;
    };
  \end{lstlisting}
  \lstset{backgroundcolor=\color{noteBackground}}
  \begin{lstlisting}
    int main()
    {
      Gassy betty(18, true); // Requires two arguments!

      Gassy alan; // error!
    }
  \end{lstlisting}
  A class can have many different constructors, as long as they have different parameters and/or types. 
  \begin{definition}{Constructor Overloading}
    When we have multiple constructors in a class, we call this \emph{constructor overloading}.
  \end{definition}
  \begin{note}{}
    If you have a constructor that doesn't take any parameters, you may omit the parentheses when creating an instance of the class.
  \end{note}
  \subsection{When Constructors are Called}
  \begin{itemize}
    \item When you create a new variable of a class.
    \item A constructor is called $N$ times when you create an array of size $N$ (that holds the object type).
    \item A constructor is called when you use \texttt{new} to dynamically allocate a new variable.
    \item If a variable is declared in a loop, it is newly constructed during \emph{every} iteration.
    \item A constructor is \emph{not called} when you just define a pointer variable.
  \end{itemize}
  \subsection{Destructors}
  Just as every class has a constructor, every class also has a destructor function (it may have \emph{exactly one} destructor). It does not have any parameters. To define a constructor function, place a tilde $n$ front of the name of the class, i.e.
  \lstset{backgroundcolor=\color{codeBackground}}
  \begin{lstlisting}
    class Gassy
    {
    public:
      ~Gassy()
      {
        // Destructor code goes here
      }
    private:
      ...
    }
  \end{lstlisting}
  \subsubsection{Why Do We Need Destructors?}
  If we did not have a destructor, everytime we create a new instance of the class we would take up more and more memory, eventually running out of memory on our system. We need to use destructors to free up memory taken up by deleted objects.
  \begin{definition}{Memory leak}
    A \emph{memory leak} occurs when you delete an object without first clearing all of the reserved space for that object, effectively ``leaking'' memory.
  \end{definition}
  \subsection{When Must You Have a Destructor?}
  \begin{center}
    \begin{tabular}{cc}
      Any time a class allocates & Your class must have \\
      a system resource\ldots & a destructor that\ldots \\[10pt]
      Reserves memory using  & Frees the allocated memory \\
      the \texttt{new} command & with the \texttt{delete} command \\[10pt]
      Opens a disk file & Closes the disk file \\[10pt]
      Connects to another computer  & Disconnects from the \\
      over the network & other computer 
    \end{tabular}
  \end{center}
  \newpage
  \section{Class Composition}
  \textbf{Main Idea.} Classes inside classes. Need I say more?
  \subsection{Construction Order}
  \begin{itemize}
    \item C++ always constructs member variables first, in the order that they're defined in the class.
    \item Then, C++ constructs the outer class after the member variables have been initialised/constructed.
  \end{itemize}
  \begin{note}{}
    This makes sense. Since the outer class constructor might need the member variables for construction, they must be constructed before the outer variable.
  \end{note}
  \subsection{Destruction Order}
  \begin{itemize}
    \item C++ always runs the main/outer object's destructor first. Its member variables are still valid when the outer destructor runs, so the outer destructor can run properly.
    \item After the outer class's destructor runs, then C++ runs the destructors of the member variables in the \emph{reverse order} they were constructed.
  \end{itemize}
  \begin{note}{Auto-generated Constructors/Destructors}
    If we leave out a constructor and/or destructor, C++ auto-generates an empty constructor and/or destructor for your class. Be careful, because the default constructor will not initialise your primitive member variables. If your class has any primitives you should define your own constructor and initialise them.
  \end{note}
  \subsection{Initialiser Lists}
  Any time you have a member variable that requires \emph{one or more} parameters for construction, you \emph{must} add an initaliser list to \emph{all} of your outer class's constructor. The syntax is as follows:
  \begin{lstlisting}
    class HungryNerd
    {
    public:
      HungryNerd() :
        myBelly(10), myBrain(150), myAge(19) // Runs the corresponding constructors
                                                 // with the given values
      {
        myBelly.eat();
      }
    private:
      Belly myBelly;
      Brain myBrain;
      int myAge;
    };
  \end{lstlisting}
  \newpage
  \section{Miscellaneous Topics}
  \subsection{Include Etiquette}
  \begin{enumerate}[label=(\alph*)]
    \item \emph{Never} include a \texttt{.cpp} file in another \texttt{.cpp} or \texttt{.h} file.
    \item \emph{Never} put a \texttt{using namespace} command in a header file. This is called ``namespace pollution'' and is bad because it forces \texttt{.cpp} files that include the header file to use its namespace. Instead, put all of the \texttt{using} commands into your C++ files.
    \item \emph{Never} assume that a header file will include some other header file for you. If whoever manages the header file decides to change its implementation, then that will break your code.
  \end{enumerate}
  \subsection{Preprocessor Directives (Include Guards)}
  \textbf{Problem.} If our header file that we are including already includes another dependency that we are already including in our \texttt{.cpp} file, then we will have included that dependency twice! This causes issues like defining methods multiple times, etc.
  \begin{enumerate}[label=(\alph*)]
    \item First, we use \texttt{\#define} to define new constants, i.e. \texttt{\#define FOOBAR\_H}
    \item We then use the commands \texttt{\#ifdef} and/or \texttt{\#ifndef} to check if a variable has been defined (or not). To close the if statement, we use the \texttt{\#endif} command.
  \end{enumerate}
  Putting both of the above steps, we have something like this:
  \begin{lstlisting}
    #ifndef FOOBAR_H // Only run the following if FOOBAR_H isn't defined
    #define FOOBAR_H // Define FOOBAR_H
    // Notice that this only runs if it has not been run before
    class FooBar
    {
    public:
      some stuff...
    private:
      some other stuff...
    };
    #endif // End the if statement
  \end{lstlisting}
  We call this an ``include guard'', because it ``guards'' the class and prevents it from being included multiple times.
  \subsection{When to Include .h Files}
  You must include the header file (containing the full definition of the class) when:
  \begin{itemize}
    \item You define a regular variable of that class' type.
    \item You use the variable in any way (call a method on it, return it, etc).
  \end{itemize}
  You must do this because C++ needs to know the class's details in order to actually do anything with instances of that class. \\[10pt]
  You must give a class declaration (just \texttt{class ClassName;}) when:
  \begin{itemize}
    \item You use the class to define a parameter to a function.
    \item You use the class as the return type for a function.
    \item You use the class to define a pointer or reference variable.
  \end{itemize}
  Since you aren't actually using any of the methods of the class nor creating any instances of the class, you don't need to include the full class definition.
  \begin{note}{}
    The reason why we don't always include the full class definition is because the header file might be large (i.e. thousands of lines) or two classes refer to each other (causing a loop).
  \end{note}
  \subsection{Default Arguments}
  You can specify a default number of arguments for a function by defining it in the function header, i.e.
  \begin{lstlisting}
    void doSomething(int varOne = 0, string varTwo = "some value")
    {
      do something with the parameters...
    }
  \end{lstlisting}
  You can leave out the default parameter if you want and C++ will automatically pass in the default value, i.e. \texttt{doSomething(5);} or \texttt{doSomething();}. However, you can only pass the first $k$ elements as defaults, and may not skip defaults, i.e. \texttt{doSomething(,"some string")} is invalid. \\[10pt]
  One final quirk about default arguments is that if the $j$th parameter has a default value, then all of the subsequent parameters ($j+1$ to $n$) \emph{must} also have default values.
\end{document}
